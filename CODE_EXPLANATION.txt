================================================================================
MY STUDY LIFE - FULL-STACK APPLICATION CODE EXPLANATION
================================================================================

TABLE OF CONTENTS:
1. HTML FILES EXPLANATION
2. CSS STYLING EXPLANATION
3. JAVASCRIPT (FRONTEND) EXPLANATION
4. FASTAPI (BACKEND) EXPLANATION
5. DATA FLOW EXAMPLES

================================================================================
PART 1: HTML FILES EXPLANATION
================================================================================

------- 1.1 LOGIN PAGE (login.html) -------

Structure:
  <html>
    <head>
      - Meta tags for character encoding and viewport (responsive)
      - Links to CSS file, Font Awesome icons, api.js script
    </head>
    <body>
      <div class="split-screen">
        <div class="left-panel">
          - Marketing content: Logo, features, stats, mission
          - Shows app benefits to users
        
        <div class="right-panel">
          - Login form
          - Email input (type="email")
          - Password input (type="password", minlength="8")
          - Error message display area (hidden by default)
          - Submit button (triggers handleLogin() function)

Key HTML Elements:
  <form id="loginForm">
    - id="loginForm" connects to JavaScript handleLogin() function
    - When user submits, handleLogin() prevents default and sends AJAX request

  <input type="email" id="email">
    - type="email" validates email format
    - JavaScript gets value via: document.getElementById('email').value

  <input type="password" id="password" minlength="8">
    - type="password" hides typed characters
    - minlength="8" forces at least 8 characters

  <div id="errorMsg" style="display: none;">
    - Hidden by default (display: none)
    - JavaScript shows it when login fails
    - JavaScript sets text: document.getElementById('errorMsg').textContent = msg

How It Works:
  1. User enters email and password
  2. User clicks "Sign In" button
  3. Form submit event triggers handleLogin()
  4. handleLogin() prevents page reload (e.preventDefault())
  5. Gets values from input fields
  6. Sends POST request to backend /api/auth/login
  7. Backend returns JWT token
  8. Frontend stores token in localStorage
  9. Redirects to dashboard


------- 1.2 SIGNUP PAGE (signup.html) -------

Similar to login but with additional fields:

  <input type="text" id="fullName">
    - Gets user's full name

  <select id="courseSelect">
    <option value="TNPSC">TNPSC</option>
    <option value="SSC">SSC</option>
    <option value="Railway">Railway</option>
    <option value="Banking">Banking</option>
  </select>
    - Dropdown to select exam course
    - JavaScript: document.getElementById('courseSelect').value

  <input type="email" id="email">
  <input type="password" id="password" minlength="8">

JavaScript gets all values:
  const fullName = document.getElementById('fullName').value;
  const course = document.getElementById('courseSelect').value;
  const email = document.getElementById('email').value;
  const password = document.getElementById('password').value;

Sends to backend:
  {
    email: "user@example.com",
    full_name: "John Doe",
    course: "TNPSC",
    password: "securePass123"
  }


------- 1.3 MY NOTES PAGE (my_notes.html) -------

Three Main Sections:

1. SEARCH & FILTER SECTION:
  <input type="text" id="search-notes" placeholder="Search your notes...">
    - User types to search notes by title/description
    - JavaScript filters on input event

  <select id="sort-filter">
    <option value="newest">Newest</option>
    <option value="oldest">Oldest</option>
    <option value="starred">Starred</option>
    <option value="az">A - Z</option>
  </select>
    - Dropdown to sort notes
    - JavaScript re-renders when changed

2. NOTE CREATION SECTION:
  <input type="text" id="note-title-input" placeholder="Note Title">
    - User enters note title

  <textarea id="note-description-input" placeholder="Write your note..."></textarea>
    - Multi-line text for note content
    - Rows expand as user types

  <input type="color" id="note-color-picker" value="#fff7b1">
    - Color picker (default yellow)
    - Returns hex color like "#fff7b1"

  <button id="save-note-btn">Add Note</button>
    - Click triggers note creation
    - Sends to backend via createNote()

3. NOTES DISPLAY SECTION:
  <div class="notes-grid" id="notes-grid">
    <!-- Notes will be dynamically loaded here -->
  </div>
    - Empty container
    - JavaScript fills with note cards using renderNotesToGrid()

4. EDIT MODAL:
  <div id="update-modal">
    - Hidden popup for editing note
    - Shows when user clicks edit button
    - Contains: title input, content textarea, color picker
    - Update button saves changes

5. VIEW MODAL:
  <div id="note-view-modal">
    - Shows full note when user clicks card
    - Displays title, description, date, color


------- 1.4 QUIZ PAGE (quiz.html) -------

Structure:
  <div class="topbar">
    - Shows question number and timer

  <div class="question-card">
    <div class="question-number">Question 1 of 50</div>
    <div class="question-text">What is the capital of India?</div>
    
    <div class="options">
      <div class="option">
        <input type="radio" name="q1" value="a" id="q1a">
        <label for="q1a">Mumbai</label>
      </div>
      <!-- More options... -->
    </div>

Key Points:
  - type="radio" ensures only 1 answer selected per question
  - name="q1" groups all options for question 1
  - value="a" is what gets submitted if selected
  - Multiple questions each have name="q2", name="q3", etc.

Submission:
  <button id="submit-quiz">Submit Quiz</button>
    - Collects all selected answers
    - Creates object: { "1": "a", "2": "c", "3": "b", ... }
    - Sends to backend /api/quiz/submit/{quiz_id}
    - Backend calculates score and saves result


================================================================================
PART 2: CSS STYLING EXPLANATION
================================================================================

------- 2.1 CSS VARIABLES (ROOT) -------

:root {
    --primary-blue: #0A2647;      /* Dark blue - main color */
    --accent-blue: #205295;        /* Medium blue */
    --text-dark: #1A1A1A;          /* Almost black */
    --text-muted: #666;            /* Gray text */
    --white: #FFFFFF;              /* White */
    --bg-light: #F8FAFC;           /* Light blue-gray background */
    --pink: #D1185A;               /* Pink highlight */
}

Why use CSS variables?
  ✓ Change color scheme by updating :root
  ✓ Reuse colors throughout file
  ✓ Easier to maintain
  ✓ Use with var(--color-name)

Example:
  background: var(--primary-blue);  /* Uses #0A2647 */


------- 2.2 LOGIN PAGE CSS (login.css) -------

.split-screen {
    display: flex;                /* Side-by-side layout */
    width: 100%;                  /* Full width */
}

.left-panel {
    flex: 1;                      /* Takes 50% width */
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                  /* Purple gradient background */
    display: flex;
    flex-direction: column;       /* Stack items vertically */
    justify-content: center;      /* Center vertically */
    align-items: center;          /* Center horizontally */
    padding: 60px;
    color: white;
}

.right-panel {
    flex: 1;                      /* Takes 50% width */
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
}

.login-box {
    width: 100%;
    max-width: 450px;             /* Don't get wider than 450px */
}

Input Styling:
.input-group input {
    width: 100%;
    padding: 12px;                /* Internal spacing */
    border: 1px solid #e0e0e0;    /* Light gray border */
    border-radius: 8px;
    outline: none;
    transition: border-color 0.3s;  /* Smooth border change */
}

.input-group input:focus {
                                  /* When clicked/focused */
    border-color: #2c5aa0;        /* Border becomes blue */
    box-shadow: 0 0 5px rgba(44, 90, 160, 0.3);  /* Blue glow */
}

Button Styling:
.btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                  /* Purple gradient */
    color: white;
    border: none;
    border-radius: 8px;
    padding: 12px;
    font-weight: 600;
    cursor: pointer;
    transition: opacity 0.3s;
}

.btn:hover {
    opacity: 0.9;                 /* Slightly transparent */
}

.btn:active {
    opacity: 0.8;                 /* More transparent when clicked */
}


------- 2.3 MY NOTES CSS (my_notes.css) -------

Search Box:
.search-box {
    position: relative;           /* For icon positioning */
}

.search-box i {
                                  /* Icon (magnifying glass) */
    position: absolute;
    left: 15px;
    top: 50%;
    transform: translateY(-50%);  /* Center vertically */
    color: #94abcb;
}

.search-box input {
    padding: 12px 15px 12px 45px; /* Extra left padding for icon */
    width: 100%;
}

Note Editor Card:
.note-editor-card {
    border: 3px solid #000000;    /* Thick black border */
    border-radius: 15px;
    padding: 30px;
    box-shadow: 0 4px 25px rgba(0, 0, 0, 0.03);
}

Color Picker:
.color-picker-btn {
    width: 60px;
    height: 60px;
    border: 2px solid #000;
    border-radius: 8px;
    cursor: pointer;
}

Notes Grid:
.notes-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                          /* Responsive grid: cards at least 280px */
    gap: 20px;            /* Space between cards */
}

Note Card:
.note-card {
    background: #fff7b1;          /* Yellow background */
    border: 2px solid #000;
    border-radius: 10px;
    padding: 20px;
    cursor: pointer;
    transition: transform 0.3s, box-shadow 0.3s;
}

.note-card:hover {
    transform: translateY(-5px);  /* Lift up 5px */
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);  /* Bigger shadow */
}

Card Actions (Star, Edit, Delete):
.starred-btn:hover { color: #ffc107; }  /* Gold on hover */
.edit-btn:hover { color: #2563eb; }     /* Blue on hover */
.delete-btn:hover { color: #dc2626; }   /* Red on hover */


------- 2.4 TNPSC PAGE CSS (tnpsc.css) -------

Program Grid:
.programs-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);  /* 4 equal columns */
    gap: 20px;
}

Program Card:
.program-card {
    position: relative;           /* For overlay */
    height: 400px;
    border-radius: 20px;
    overflow: hidden;             /* Clip content outside border */
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
    transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.program-card:hover {
    transform: translateY(-10px); /* Lift up on hover */
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.2);  /* More shadow */
}

Program Image Zoom:
.program-image {
    width: 100%;
    height: 100%;
    object-fit: cover;            /* Scale to fill */
    transition: transform 0.5s ease;
}

.program-card:hover .program-image {
    transform: scale(1.1);        /* Zoom 10% when card hovered */
}

Card Overlay (Gradient):
.card-overlay {
    position: absolute;           /* On top of image */
    bottom: 0;
    height: 50%;
    background: linear-gradient(to top, rgba(0, 0, 0, 0.7) 0%, transparent 100%);
                                  /* Dark at bottom, fades up */
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
}

Accordion:
.accordion-item {
    background: white;
    border-radius: 16px;
    border: 1px solid #E2E8F0;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
    overflow: hidden;
}

.accordion-header {
    padding: 24px;
    display: flex;
    justify-content: space-between;  /* Title left, icon right */
    cursor: pointer;
}

.accordion-header i {
    transition: transform 0.4s cubic-bezier(...);  /* Smooth rotation */
}

.accordion-content {
    padding: 0 24px 24px;
    display: none;                /* Hidden by default */
    animation: fadeIn 0.4s ease;  /* Fade in animation when shown */
}

Active Accordion Item:
.accordion-item.active .accordion-header i {
    transform: rotate(180deg);    /* Icon flips 180° */
}

.accordion-item.active .accordion-content {
    display: block;               /* Show content */
}

Responsive Design:
@media (max-width: 992px) {
    .detail-container {
        flex-direction: column;   /* Stack vertically on tablet */
    }
    .accordion-col {
        position: static;         /* Remove sticky positioning */
    }
}

@media (max-width: 768px) {
    .programs-grid {
        grid-template-columns: 1fr;  /* Single column on mobile */
    }
}


================================================================================
PART 3: JAVASCRIPT (FRONTEND) EXPLANATION
================================================================================

------- 3.1 TOKEN MANAGEMENT -------

const baseUrl = 'http://127.0.0.1:8000';  /* Backend server address */

function getToken() {
  return localStorage.getItem('mst_token');
                                  /* Get JWT from browser storage */
}

function setToken(token) {
  localStorage.setItem('mst_token', token);
                                  /* Save JWT to browser storage */
}

function clearToken() {
  localStorage.removeItem('mst_token');   /* Remove JWT (logout) */
}

localStorage Explanation:
  - Persistent storage in browser (survives page refresh)
  - Stores key-value pairs
  - Can be inspected in DevTools → Application → Local Storage
  - Used to remember user even after page reload

JWT Token Flow:
  1. User login → Backend returns JWT
  2. setToken() saves to localStorage
  3. getToken() retrieves before each API call
  4. Include in Authorization header: "Bearer " + token
  5. clearToken() deletes on logout


------- 3.2 LOGIN FUNCTION -------

async function handleLogin(e) {
  e.preventDefault();               /* Prevent page reload */
  
  /* Get email & password from input fields */
  const email = document.getElementById('email').value;
  const password = document.getElementById('password').value;
  
  /* Format as URLSearchParams (FastAPI expects form data) */
  const body = new URLSearchParams();
  body.append('username', email);   /* 'username' is FastAPI convention */
  body.append('password', password);

  try {
    /* Send POST request to backend */
    const res = await fetch(`${baseUrl}/api/auth/login`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: body
    });
    
    /* Check if response is OK */
    if (!res.ok) {
      const errorData = await res.json();
      showError(errorData.detail || 'Login failed');
      return;
    }
    
    /* Get JWT token from response */
    const data = await res.json();  /* data = { access_token, token_type } */
    setToken(data.access_token);    /* Save JWT to localStorage */
    window.location.href = '../general/dashboard.html';  /* Redirect */
  } catch (err) {
    showError('Network error');
    console.error(err);
  }
}

Step-by-step:
  1. User clicks login button
  2. handleLogin() called with form submit event
  3. e.preventDefault() stops form from reloading page
  4. Get email and password from input elements
  5. Create URLSearchParams body
  6. Send POST to /api/auth/login
  7. If error: show error message in red
  8. If success: get JWT → save → redirect to dashboard


------- 3.3 SIGNUP FUNCTION -------

async function handleSignup(e) {
  e.preventDefault();
  
  /* Get all form fields */
  const fullName = document.getElementById('fullName').value;
  const course = document.getElementById('courseSelect').value;
  const email = document.getElementById('email').value;
  const password = document.getElementById('password').value;

  /* Create JSON payload */
  const payload = {
    email: email,
    full_name: fullName,
    course: course,
    password: password
  };

  try {
    /* Send POST request */
    const res = await fetch(`${baseUrl}/api/auth/signup`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)  /* Convert object to JSON */
    });
    
    if (!res.ok) {
      const errorData = await res.json();
      showError(errorData.detail || 'Signup failed');
      return;
    }
    
    /* Redirect to login after successful signup */
    window.location.href = 'login.html';
  } catch (err) {
    showError('Network error');
  }
}

Difference from login():
  - Uses JSON.stringify() instead of URLSearchParams
  - Includes full_name and course
  - Sends to /api/auth/signup (not /api/auth/login)
  - Redirects to login (not dashboard)


------- 3.4 QUIZ FUNCTIONS -------

async function getQuizzesAll() {
                                  /* Fetch all quizzes */
  try {
    const res = await fetch(`${baseUrl}/api/quiz/all`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });
    if (!res.ok) return { success: false, data: [] };
    const data = await res.json();
    return { success: true, data: data };
  } catch (err) {
    console.error('Error fetching quizzes:', err);
    return { success: false, data: [] };
  }
}

Purpose: Get list of all available quizzes
Returns: { success: true, data: [quiz1, quiz2, ...] }

async function getQuizWithQuestions(quizId) {
                                  /* Get quiz + all questions */
  try {
    const res = await fetch(`${baseUrl}/api/quiz/${quizId}`, {
      method: 'GET',
      headers: { 'Content-Type': 'application/json' }
    });
    if (!res.ok) return { success: false, data: null };
    const data = await res.json();
    return { success: true, data: data };
  } catch (err) {
    console.error('Error fetching quiz:', err);
    return { success: false, data: null };
  }
}

Purpose: Load specific quiz with all 50 questions
Returns: { success: true, data: { id, title, questions: [...] } }

async function submitQuiz(quizId, answers) {
                                  /* Submit answers & get score */
  const token = getToken();
  if (!token) {
    alert('Please login first');
    return { success: false, data: null };
  }
  
  try {
    const payload = {
      quiz_id: parseInt(quizId),
      answers: answers             /* { "1": "a", "2": "b", ... } */
    };
    
    const res = await fetch(`${baseUrl}/api/quiz/submit/${quizId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`  /* Include JWT */
      },
      body: JSON.stringify(payload)
    });
    
    if (!res.ok) {
      const errorData = await res.json();
      console.error('Error submitting quiz:', errorData.detail);
      return { success: false, data: null };
    }
    
    const data = await res.json();
    return { success: true, data: data };
                                  /* { score, correct, wrong, total } */
  } catch (err) {
    console.error('Error submitting quiz:', err);
    return { success: false, data: null };
  }
}

Key Points:
  - Gets JWT token first (required for authenticated route)
  - answers parameter: { "1": "a", "2": "c", "3": "a", ... }
  - Sends JWT in Authorization header
  - Backend calculates score and saves to database
  - Returns score percentage, correct count, wrong count


------- 3.5 NOTES FUNCTIONS -------

async function createNote(title, description, color = '#ffffff') {
                                  /* Create new note */
  const token = getToken();
  if (!token) {
    alert('Please login first');
    return { success: false, data: null };
  }
  
  try {
    const payload = {
      title: title,
      description: description,
      color: color                 /* Hex color like #fff7b1 */
    };
    
    const res = await fetch(`${baseUrl}/api/notes/`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(payload)
    });
    
    if (!res.ok) {
      const errorData = await res.json();
      console.error('Error creating note:', errorData.detail);
      return { success: false, data: null };
    }
    
    const data = await res.json();
    return { success: true, data: data };
  } catch (err) {
    console.error('Error creating note:', err);
    return { success: false, data: null };
  }
}

Purpose: Create new note for logged-in user
Backend automatically links to user via JWT

async function updateNote(noteId, title, description, color) {
                                  /* Update existing note */
  const token = getToken();
  if (!token) return { success: false };
  
  try {
    const payload = { title, description, color };
    const res = await fetch(`${baseUrl}/api/notes/${noteId}`, {
      method: 'PUT',                /* PUT = Update resource */
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(payload)
    });
    
    const data = await res.json();
    return { success: res.ok, data };
  } catch (err) {
    console.error('Error updating note:', err);
    return { success: false };
  }
}

async function deleteNote(noteId) {
                                  /* Delete note */
  const token = getToken();
  if (!token) return { success: false };
  
  try {
    const res = await fetch(`${baseUrl}/api/notes/${noteId}`, {
      method: 'DELETE',
      headers: { 'Authorization': `Bearer ${token}` }
    });
    return { success: res.ok };
  } catch (err) {
    console.error('Error deleting note:', err);
    return { success: false };
  }
}

async function toggleStar(noteId) {
                                  /* Star/unstar note */
  const token = getToken();
  if (!token) return { success: false };
  
  try {
    const res = await fetch(`${baseUrl}/api/notes/${noteId}/star`, {
      method: 'PATCH',              /* PATCH = Update specific field */
      headers: { 'Authorization': `Bearer ${token}` }
    });
    const data = await res.json();
    return { success: res.ok, data };
  } catch (err) {
    console.error('Error toggling star:', err);
    return { success: false };
  }
}


------- 3.6 PAGE HANDLERS & RENDERING -------

function filterAndSortNotes() {
                                  /* Filter by search, sort by option */
  const searchTerm = document.getElementById('search-notes')?.value.toLowerCase() || '';
  const sortBy = document.getElementById('sort-filter')?.value || 'newest';

  /* Filter notes by search term */
  let filtered = allNotes.filter(n =>
    n.title.toLowerCase().includes(searchTerm) ||
    (n.description && n.description.toLowerCase().includes(searchTerm))
  );

  /* Sort based on selection */
  if (sortBy === 'newest') {
    filtered.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
  } else if (sortBy === 'oldest') {
    filtered.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
  } else if (sortBy === 'starred') {
    filtered = filtered.filter(n => n.is_starred);
  } else if (sortBy === 'az') {
    filtered.sort((a, b) => a.title.localeCompare(b.title));  /* A-Z */
  }

  return filtered;
}

Purpose: Filter locally in JavaScript (no backend call needed)

function renderNotesToGrid(notesList) {
                                  /* Display notes in grid */
  const grid = document.getElementById('notes-grid');
  if (!grid) return;
  
  /* Map each note to HTML, join into one string */
  grid.innerHTML = notesList.map(note => {
    const date = new Date(note.created_at).toLocaleDateString('en-US', {
      month: 'short', day: 'numeric', year: 'numeric'
    });
    
    return `
      <div class="note-card" data-id="${note.id}" 
           style="background-color: ${note.color || '#fff7b1'};">
        <div class="card-actions">
          <span class="starred-btn">
            <i class="${note.is_starred ? 'fa-solid' : 'fa-regular'} fa-star"></i>
          </span>
          <span class="edit-btn"><i class="fa-solid fa-pen"></i></span>
          <span class="delete-btn"><i class="fa-solid fa-trash"></i></span>
        </div>
        <h3>${note.title}</h3>
        <p>${note.description || ''}</p>
        <span class="note-date">${date}</span>
      </div>
    `;
  }).join('');
}

Breakdown:
  1. Get notes-grid element
  2. For each note, create HTML card template
  3. ${note.is_starred ? 'fa-solid' : 'fa-regular'} = filled star if starred, outline if not
  4. data-id="${note.id}" stores note ID for delete/edit
  5. Join all HTML strings
  6. Set grid.innerHTML = combined HTML

async function loadAndRenderNotes() {
                                  /* Load notes and display */
  const res = await getNotes();
  if (res.success) {
    allNotes = res.data;           /* Cache locally */
    renderNotesToGrid(filterAndSortNotes());  /* Display */
  }
}

Purpose: Called when page loads or note created/deleted


================================================================================
PART 4: FASTAPI (BACKEND) EXPLANATION
================================================================================

------- 4.1 PROJECT SETUP -------

File: main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from database import Base, engine
from models import User, Quiz, Question, UserAnswer, Progress, Note
from routers import auth_router, quiz_router, progress_router, notes_router
from config import settings

/* Create database tables */
Base.metadata.create_all(bind=engine)

/* Create FastAPI app */
app = FastAPI(
    title=settings.APP_NAME,
    version=settings.APP_VERSION
)

/* Add CORS middleware (allows frontend to call backend) */
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],           /* Allow all origins (change in production) */
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

/* Include routers */
app.include_router(auth_router)
app.include_router(quiz_router)
app.include_router(progress_router)
app.include_router(notes_router)

@app.get("/")
def read_root():
    return { "message": "Welcome to My Study Life API" }

@app.get("/health")
def health_check():
    return { "status": "healthy" }

To run:
  python main.py
  Start server on http://localhost:8000


File: config.py
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    DATABASE_URL: str = "postgresql+psycopg2://postgres:Password@localhost:5432/my_study_life"
    SECRET_KEY: str = "your-secret-key-change-in-production"
    ALGORITHM: str = "HS256"          /* JWT algorithm */
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    class Config:
        env_file = ".env"

settings = Settings()

Purpose:
  - DATABASE_URL: PostgreSQL connection string
  - SECRET_KEY: Used to sign JWT tokens
  - ACCESS_TOKEN_EXPIRE_MINUTES: JWT expires after 30 mins


File: database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from config import settings

/* Create database engine */
engine = create_engine(
    settings.DATABASE_URL,
    echo=True                       /* Log all SQL queries */
)

/* Session maker - creates database sessions */
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

/* Base class for models */
Base = declarative_base()

def get_db():
    """Dependency for getting database session"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


------- 4.2 MODELS (DATABASE SCHEMA) -------

Each model = database table

User Model (users table):
from sqlalchemy import Column, Integer, String, DateTime
from database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)        /* Never plaintext */
    full_name = Column(String)
    course = Column(String, default=None)  /* TNPSC, SSC, etc */
    created_at = Column(DateTime, default=datetime.utcnow)

Fields:
  - id: Unique identifier (auto-increment)
  - email: User email (must be unique)
  - hashed_password: Password (bcrypt hashed)
  - full_name: User's name
  - course: Exam course selected
  - created_at: Registration timestamp


Quiz Model (quizzes table):
class Quiz(Base):
    __tablename__ = "quizzes"
    
    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True)     /* "Grade 6 Tamil Quiz" */
    subject = Column(String, index=True)   /* Tamil, English, Math */
    grade = Column(Integer)                /* 6, 7, 8, 9, 10 */
    total_questions = Column(Integer)      /* 50, 100, 300 */
    description = Column(Text, nullable=True)


Question Model (questions table):
class Question(Base):
    __tablename__ = "questions"
    
    id = Column(Integer, primary_key=True, index=True)
    quiz_id = Column(Integer, ForeignKey("quizzes.id"))
    question_text = Column(Text)
    option_a = Column(String)
    option_b = Column(String)
    option_c = Column(String)
    option_d = Column(String)
    correct_answer = Column(String)        /* "a", "b", "c", or "d" */

ForeignKey: Links to Quiz (each question belongs to a quiz)


Progress Model (progress table):
class Progress(Base):
    __tablename__ = "progress"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    quiz_id = Column(Integer, ForeignKey("quizzes.id"))
    total_questions = Column(Integer)
    correct_answers = Column(Integer)
    wrong_answers = Column(Integer)
    score = Column(Float)                  /* Percentage like 72.5 */
    completed_at = Column(DateTime, default=datetime.utcnow)

Purpose: Store quiz results for each user


Note Model (notes table):
class Note(Base):
    __tablename__ = "notes"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    title = Column(String, index=True)
    description = Column(String)
    color = Column(String, default="#fff7b1")  /* Hex color */
    is_starred = Column(Boolean, default=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

Purpose: Store student notes


------- 4.3 AUTHENTICATION ROUTER -------

File: routers/auth.py

@router.post("/signup", response_model=UserResponse)
def signup(user: UserCreate, db: Session = Depends(get_db)):
    """User registration endpoint"""
    
    /* Check if email already exists */
    db_user = db.query(User).filter(User.email == user.email).first()
    if db_user:
        raise HTTPException(
            status_code=400,
            detail="Email already registered"
        )
    
    /* Hash password (never store plaintext) */
    hashed_password = hash_password(user.password)
    
    /* Create new user */
    db_user = User(
        email=user.email,
        hashed_password=hashed_password,
        full_name=user.full_name,
        course=user.course
    )
    
    /* Save to database */
    db.add(db_user)         /* Add to session */
    db.commit()             /* Save changes */
    db.refresh(db_user)     /* Get generated ID */
    
    return db_user

Step-by-step:
  1. Receive user data: email, full_name, course, password
  2. Check if email exists (if yes, error)
  3. Hash password using bcrypt
  4. Create User object
  5. Add to database session
  6. Commit (save)
  7. Return user data


@router.post("/login", response_model=Token)
def login(form_data: OAuth2PasswordRequestForm = Depends(), 
          db: Session = Depends(get_db)):
    """User login endpoint"""
    
    email = form_data.username  /* Frontend sends email as username */
    password = form_data.password
    
    /* Find user by email */
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise HTTPException(
            status_code=401,
            detail="Invalid credentials"
        )
    
    /* Verify password */
    if not verify_password(password, user.hashed_password):
        raise HTTPException(
            status_code=401,
            detail="Invalid credentials"
        )
    
    /* Create JWT token */
    access_token = create_access_token(data={"sub": user.email})
    
    return {
        "access_token": access_token,
        "token_type": "bearer"
    }

Step-by-step:
  1. Receive email and password
  2. Find user in database
  3. If not found, error
  4. Compare plaintext password with hashed version
  5. If mismatch, error
  6. Create JWT token containing user's email
  7. Return token


@router.get("/me", response_model=UserResponse)
def get_current_user(
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """Get current logged-in user"""
    
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing authorization header")
    
    /* Extract token from "Bearer <token>" */
    parts = authorization.split()
    token = parts[-1]
    
    /* Decode JWT to get email */
    email = decode_token(token)
    if not email:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    /* Find user */
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise HTTPException(status_code=401, detail="User not found")
    
    return user

Purpose: Get profile of logged-in user


------- 4.4 QUIZ ROUTER -------

File: routers/quiz.py

@router.get("/all", response_model=list[QuizResponse])
def get_all_quizzes(db: Session = Depends(get_db)):
    """Get all available quizzes"""
    quizzes = db.query(Quiz).all()
    return quizzes

Return all quizzes (no authentication needed - anyone can view)


@router.get("/{quiz_id}", response_model=QuizWithQuestions)
def get_quiz_with_questions(quiz_id: int, db: Session = Depends(get_db)):
    """Get specific quiz with all questions"""
    
    /* Find quiz */
    quiz = db.query(Quiz).filter(Quiz.id == quiz_id).first()
    if not quiz:
        raise HTTPException(status_code=404, detail="Quiz not found")
    
    /* Get all questions for this quiz */
    questions = db.query(Question).filter(Question.quiz_id == quiz_id).all()
    
    return {
        "id": quiz.id,
        "title": quiz.title,
        "subject": quiz.subject,
        "grade": quiz.grade,
        "total_questions": quiz.total_questions,
        "questions": questions  /* Include all questions */
    }


@router.post("/submit/{quiz_id}")
def submit_quiz(
    quiz_id: int,
    submission: QuizSubmission,  /* { quiz_id, answers: {...} } */
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """Submit quiz answers and calculate score"""
    
    /* Get user from JWT */
    user_id = get_current_user_id(authorization, db)
    
    /* Get all questions for this quiz */
    questions = db.query(Question).filter(Question.quiz_id == quiz_id).all()
    
    correct_count = 0
    wrong_count = 0
    
    /* Check each answer */
    for question in questions:
        user_answer_key = str(question.id)
        if user_answer_key in submission.answers:
            user_answer = submission.answers[user_answer_key]
            
            /* Compare user answer with correct answer */
            is_correct = user_answer.lower() == question.correct_answer.lower()
            
            /* Save user's answer */
            db_user_answer = UserAnswer(
                user_id=user_id,
                quiz_id=quiz_id,
                question_id=question.id,
                user_answer=user_answer,
                is_correct=is_correct
            )
            db.add(db_user_answer)
            
            if is_correct:
                correct_count += 1
            else:
                wrong_count += 1
    
    /* Calculate percentage */
    total = correct_count + wrong_count
    score_percentage = (correct_count / total * 100) if total > 0 else 0
    
    /* Save progress record */
    progress = Progress(
        user_id=user_id,
        quiz_id=quiz_id,
        total_questions=total,
        correct_answers=correct_count,
        wrong_answers=wrong_count,
        score=score_percentage
    )
    
    db.add(progress)
    db.commit()
    db.refresh(progress)
    
    return {
        "score": score_percentage,
        "correct": correct_count,
        "wrong": wrong_count,
        "total": total,
        "message": f"Quiz submitted! Score: {score_percentage:.2f}%"
    }

Step-by-step:
  1. Get user from JWT
  2. Fetch all 50 questions for the quiz
  3. For each question:
     - Get user's answer from submission
     - Compare with correct_answer
     - Save to UserAnswer table
     - Count correct/wrong
  4. Calculate: score = (correct / total) * 100
  5. Create Progress record (user_id, quiz_id, score)
  6. Return score to frontend


------- 4.5 NOTES ROUTER -------

File: routers/notes.py

def get_current_user_id(authorization, db):
    """Extract user ID from JWT"""
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing auth header")
    
    parts = authorization.split()
    token = parts[-1]
    
    email = decode_token(token)
    if not email:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    user = db.query(User).filter(User.email == email).first()
    if not user:
        raise HTTPException(status_code=401, detail="User not found")
    
    return user.id


@router.post("/", response_model=NoteSchema)
def create_note(
    note: NoteCreate,
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """Create a new note for current user"""
    user_id = get_current_user_id(authorization, db)
    
    db_note = Note(
        title=note.title,
        description=note.description,
        color=note.color,
        user_id=user_id  /* Attach to logged-in user */
    )
    
    db.add(db_note)
    db.commit()
    db.refresh(db_note)
    return db_note

Purpose: Create note, automatically associated with user from JWT


@router.get("/", response_model=list[NoteSchema])
def get_user_notes(
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """Get all notes for current user"""
    user_id = get_current_user_id(authorization, db)
    
    /* Only get notes belonging to this user */
    notes = db.query(Note).filter(Note.user_id == user_id).all()
    return notes

Security: filter(Note.user_id == user_id) ensures user can only see own notes


@router.put("/{note_id}", response_model=NoteSchema)
def update_note(
    note_id: int,
    note_update: NoteUpdate,
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """Update a note"""
    user_id = get_current_user_id(authorization, db)
    
    /* Check user owns this note */
    db_note = db.query(Note).filter(
        Note.id == note_id,
        Note.user_id == user_id  /* Security: verify ownership */
    ).first()
    
    if not db_note:
        raise HTTPException(status_code=404, detail="Note not found")
    
    /* Update only provided fields */
    update_data = note_update.dict(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_note, key, value)
    
    db.commit()
    db.refresh(db_note)
    return db_note


@router.delete("/{note_id}")
def delete_note(
    note_id: int,
    authorization: Optional[str] = Header(None),
    db: Session = Depends(get_db)
):
    """Delete a note"""
    user_id = get_current_user_id(authorization, db)
    
    db_note = db.query(Note).filter(
        Note.id == note_id,
        Note.user_id == user_id
    ).first()
    
    if not db_note:
        raise HTTPException(status_code=404, detail="Note not found")
    
    db.delete(db_note)
    db.commit()
    
    return {"message": "Note deleted successfully"}


------- 4.6 SECURITY MODULE -------

File: utils/security.py

from passlib.context import CryptContext
from jose import jwt

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """Hash password using bcrypt"""
    return pwd_context.hash(password)

Example:
  Input:  "password123"
  Output: "$2b$12$abcdefghijklmnopqrst..." (impossible to reverse)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password matches hash"""
    return pwd_context.verify(plain_password, hashed_password)

Example:
  Compare("password123", "$2b$12$...") → True
  Compare("wrongpass", "$2b$12$...") → False

def create_access_token(data: dict, expires_delta=None):
    """Create JWT token"""
    to_encode = data.copy()  /* { "sub": "user@example.com" } */
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=30)
    
    to_encode.update({"exp": expire})
    
    encoded_jwt = jwt.encode(
        to_encode,
        settings.SECRET_KEY,
        algorithm=settings.ALGORITHM
    )
    return encoded_jwt

JWT Token Structure:
  Header: { "alg": "HS256", "typ": "JWT" }
  Payload: { "sub": "user@example.com", "exp": 1708123456 }
  Signature: HMACSHA256(header + payload, SECRET_KEY)

Example JWT:
  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyQGV4YW1wbGUuY29tIiwi...

def decode_token(token: str) -> str | None:
    """Decode JWT token"""
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=["HS256"])
        email = payload.get("sub")  /* Extract email from JWT */
        if email is None:
            return None
        return email
    except JWTError:  /* Token expired or invalid */
        return None


================================================================================
PART 5: DATA FLOW EXAMPLES
================================================================================

------- EXAMPLE 1: USER LOGIN -------

Frontend (login.html):
  1. User enters: email = "john@example.com", password = "pass123"
  2. Clicks "Sign In" button
  3. Form submit event triggers handleLogin()

JavaScript (api.js - handleLogin):
  4. e.preventDefault() stops page reload
  5. Gets email & password from input elements
  6. Creates URLSearchParams body
  7. Sends POST /api/auth/login
     Headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
     Body: username=john@example.com&password=pass123

Backend (routers/auth.py - login):
  8. Receives form_data
  9. email = "john@example.com"
  10. Finds user in database: db.query(User).filter(User.email == email)
  11. User found with hashed_password = "$2b$12$..."
  12. Verifies password: verify_password("pass123", "$2b$12$...") → True
  13. Creates JWT token:
      data = {"sub": "john@example.com"}
      token = jwt.encode(data, SECRET_KEY, "HS256")
      token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...."
  14. Returns JSON: { "access_token": token, "token_type": "bearer" }

JavaScript (api.js - handleLogin):
  15. Receives response: { access_token: "eyJ...", token_type: "bearer" }
  16. Calls setToken(token)
      localStorage.setItem('mst_token', "eyJ...")
  17. Redirects to dashboard.html

Result: User logged in, JWT stored in localStorage


------- EXAMPLE 2: CREATE NOTE -------

Frontend (my_notes.html):
  1. User enters: title = "Physics Notes", description = "Chapter 1", color = "#ffff00"
  2. Clicks "Add Note" button
  3. Triggers handleCreateNote()

JavaScript (api.js - handleCreateNote):
  4. Gets title, description, color from input elements
  5. Calls createNote(title, description, color)

JavaScript (api.js - createNote):
  6. Gets JWT token: localStorage.getItem('mst_token')
  7. Creates payload: { title, description, color }
  8. Sends POST /api/notes/
     Headers: {
       'Content-Type': 'application/json',
       'Authorization': 'Bearer eyJ...'  /* JWT token */
     }
     Body: { "title": "Physics Notes", "description": "Chapter 1", "color": "#ffff00" }

Backend (routers/notes.py - create_note):
  9. Receives authorization header: "Bearer eyJ..."
  10. Extracts token: parts = ["Bearer", "eyJ..."], token = "eyJ..."
  11. Decodes JWT: decode_token("eyJ...") → "john@example.com"
  12. Finds user: db.query(User).filter(User.email == "john@example.com")
  13. Gets user.id = 5
  14. Creates Note object:
      Note(
        title="Physics Notes",
        description="Chapter 1",
        color="#ffff00",
        user_id=5
      )
  15. Saves to database:
      db.add(note)
      db.commit()
      db.refresh(note)  /* Gets generated note.id */
      Returns note with id=42, user_id=5, etc.

JavaScript (api.js - handleCreateNote):
  16. Received response: { id: 42, title, description, color, user_id: 5, ... }
  17. Clears input fields
  18. Calls loadAndRenderNotes()

JavaScript (api.js - loadAndRenderNotes):
  19. Calls getNotes() to fetch all notes
  20. Backend returns list of notes for user_id=5
  21. Calls renderNotesToGrid() to display notes
  22. User sees new note displayed in grid


------- EXAMPLE 3: SUBMIT QUIZ -------

Frontend (quiz.html):
  1. User answers 50 questions:
     Q1: Selected option "a"
     Q2: Selected option "c"
     Q3: Selected option "b"
     ... (50 total)
  2. Clicks "Submit Quiz" button
  3. JavaScript collects answers: { "1": "a", "2": "c", "3": "b", ... }
  4. Calls submitQuiz(quizId=1, answers)

JavaScript (api.js - submitQuiz):
  5. Gets JWT token
  6. Creates payload: { quiz_id: 1, answers: {...} }
  7. Sends POST /api/quiz/submit/1
     Headers: { Authorization: 'Bearer eyJ...', Content-Type: 'application/json' }
     Body: { "quiz_id": 1, "answers": {"1": "a", "2": "c", ...} }

Backend (routers/quiz.py - submit_quiz):
  8. Extracts user_id=5 from JWT
  9. Fetches all 50 Question records for quiz_id=1
  10. For each question:
      - Gets user's answer from submission.answers
      - Compares with question.correct_answer
      - Creates UserAnswer record and saves
      - Counts correct/wrong
  
  Example loop:
    Question 1: user answer "a", correct "a" → CORRECT (count++)
    Question 2: user answer "c", correct "b" → WRONG (count++)
    Question 3: user answer "b", correct "b" → CORRECT (count++)
    ...
  
  11. Counts: correct=40, wrong=10, total=50
  12. Calculates: score = (40/50) * 100 = 80%
  13. Creates Progress record:
      Progress(
        user_id=5,
        quiz_id=1,
        total_questions=50,
        correct_answers=40,
        wrong_answers=10,
        score=80.0
      )
  14. Saves to database
  15. Returns JSON: { score: 80, correct: 40, wrong: 10, total: 50, message: "... 80%" }

JavaScript (api.js - submitQuiz):
  16. Receives response with score=80
  17. Shows result to user: "Congratulations! Score: 80%"
  18. Can call getProgress() to show all past quiz results

Result: Quiz saved, score calculated, progress tracked


================================================================================
KEY CONCEPTS SUMMARY
================================================================================

FRONTEND:
  ✓ HTML = Structure (forms, inputs, buttons)
  ✓ CSS = Styling (colors, layouts, animations)
  ✓ JavaScript = Interactivity (fetch API calls, DOM manipulation)
  ✓ localStorage = Persist JWT across page reloads

BACKEND:
  ✓ FastAPI = Web framework
  ✓ SQLAlchemy = ORM (Map Python classes to database tables)
  ✓ PostgreSQL = Database
  ✓ JWT = Authentication tokens
  ✓ Bcrypt = Password hashing

SECURITY:
  ✓ Never store plaintext passwords (use bcrypt)
  ✓ Use JWT for authentication (stateless)
  ✓ Include JWT in Authorization header (not URL)
  ✓ Verify user owns resource (check user_id in database)
  ✓ Use HTTPS in production (not HTTP)

API METHODS:
  ✓ GET = Fetch data (don't send body)
  ✓ POST = Create data (send body)
  ✓ PUT = Update entire resource (send body)
  ✓ PATCH = Update specific field (send body)
  ✓ DELETE = Delete data (no body)

HTTP CODES:
  ✓ 200 = OK
  ✓ 201 = Created
  ✓ 400 = Bad Request (validation error)
  ✓ 401 = Unauthorized (missing/invalid JWT)
  ✓ 404 = Not Found (resource doesn't exist)
  ✓ 500 = Server Error

================================================================================
END OF DETAILED CODE EXPLANATION
================================================================================
